# Code Frontmatter (CFM) 整改计划

> **背景**：此文档基于一位真实 AI（Google Gemini）在实际项目中测试 CFM 全部 4 个工具后的反馈。
> AI 测试了 cfm_read、cfm_search、cfm_write、cfm_register_language，功能全部通过，但发现 AI 并没有按照 CFM 设计者预期的工作流使用工具。
> 这份整改计划旨在解决"功能好但 AI 不主动用"的核心问题。

---

## 核心诊断

**CFM 的功能值 80 分，但 AI 的实际执行率只有约 40%。**

根本原因不是功能不够，而是：
1. 工具描述使用"建议"语气，AI 将其视为可选项而非必须步骤
2. AI 有自己的惯性工具（grep_search、list_dir、view_file），会优先使用它们
3. CFM 的工作流意图（先搜索→再读表头→再决定是否深读）没有被强制执行

**结论：70% 精力应放在"让 AI 无法忽略 CFM"，30% 放在新功能。**

---

## 整改任务清单

### P0-1：优化 MCP 工具描述（影响最大，改动最小）

**目标**：通过修改工具描述的措辞，让 AI 将 CFM 视为"必须执行的步骤"而非"可选参考"。

**原则**：
- 不是语气更强硬，而是**逻辑说服** — 告诉 AI "为什么用 CFM 对你（AI自己）更高效"
- **锚定触发点** — 将 CFM 操作绑定到 AI 已有的行为上（如"读文件前先查表头"）
- **量化收益** — 用具体数字说明节省效果

**具体修改**：

#### cfm_read 工具描述修改

现有描述的问题："建议在读取文件全文之前，先用此工具查看表头" — "建议"给了AI选择权。

改为类似以下表述（请根据实际代码中的描述格式调整）：

```
读取代码文件的 CFM 表头（文件的'身份证'）。

关键工作流：在对代码文件执行全文阅读前，应先调用此工具检查表头。
表头通常只有 5-10 行，包含 intent（用途）和 exports（导出接口），
可以替代阅读 100-500 行全文来判断文件是否与当前任务相关。

支持两种模式：
- 传入单个文件路径：仅返回该文件的表头（轻量）
- 传入目录路径：批量扫描该目录下所有文件的表头（较重，仅在需要项目全貌时使用）

典型用法：先用 cfm_search 定位候选文件，再用 cfm_read 检查单个文件表头，
根据 intent 和 exports 判断是否需要深入阅读全文。
```

#### cfm_search 工具描述修改

现有描述已经不错，但需要强化"首选"定位：

```
在项目中搜索匹配条件的 CFM 表头。

这是精准定位目标文件的首选入口：先搜索再决定是否深入阅读，
比逐个文件调用 grep 或 view_file 节省 5-10 倍 token。

支持三种过滤维度：
- keyword：在 intent、exports、ai_notes 等字段中全文搜索
- role：按文件角色过滤（service, component, util, config, page, model, entry）
- domain：按业务领域过滤（如 payment, auth, billing）

返回匹配文件的完整表头摘要，无需读取文件全文即可做出决策。
```

#### cfm_write 工具描述修改

需要强化"维护义务"的概念：

```
将标准 CFM 表头写入指定代码文件。

维护义务：当你修改了某个代码文件的核心逻辑、导出接口或依赖关系后，
应调用此工具更新该文件的表头，保持表头与代码的一致性。

CRITICAL: 更新表头时的规则：
1. 读取旧表头
2. 保留'永久性技术约束/经验教训'（如 ai_notes 中的警告）
3. 丢弃'变更日志/历史/流程信息'
4. 将剩余内容极致精简

禁止盲目覆盖！
```

**执行方式**：找到 CFM 项目中定义工具描述的源代码文件（通常在 src/schema.ts 或类似文件中），修改对应的 description 字段。

---

### P0-2：在 cfm_read 返回结果中加入反向依赖（depended_by）

**目标**：AI 读取某个文件的表头时，自动获知"哪些文件依赖了这个文件"，无需额外调用任何工具。

**当前行为**：
```json
{
  "file": "auth.js",
  "frontmatter": {
    "depends_on": ["js/supabase-client.js"]
  }
}
```

**期望行为**：
```json
{
  "file": "auth.js",
  "frontmatter": {
    "depends_on": ["js/supabase-client.js"]
  },
  "depended_by": ["index.html", "login.html", "user-center.html"]
}
```

**实现思路**：
1. cfm_read 单文件模式被调用时，扫描同项目下所有文件的表头（可做缓存）
2. 从所有文件的 `depends_on` 字段中反向索引，找出哪些文件的 depends_on 包含当前文件
3. 将结果作为 `depended_by` 字段追加到返回结果中
4. 这是一个"被动"功能 — AI 不需要主动调用新工具，只是 cfm_read 的返回变得更丰富

**注意事项**：
- 性能考虑：如果项目文件数量很大，每次 cfm_read 都扫描全部文件可能较慢。可以考虑缓存机制（文件修改时间未变则用缓存）
- 路径匹配：depends_on 中的路径格式需要与文件实际路径匹配（相对路径 vs 绝对路径）
- 如果没有任何文件依赖当前文件，可以返回空数组或不返回该字段

---

### P1-1：利用 MCP Resources 暴露项目摘要

**目标**：让 AI 客户端在对话开始时自动发现 CFM 提供的项目摘要，无需 AI 主动调用任何工具。

**MCP Resources 是什么**：MCP 协议中，Server 可以声明自己提供一些"资源"（Resources），类似于 REST API 的 GET 端点。AI 客户端可以 list_resources 发现它们，然后 read_resource 读取内容。

**实现方式**：
在 CFM MCP Server 中注册一个 Resource：

```
URI: cfm://project-summary
Name: "项目 CFM 表头覆盖概况"
```

内容示例（保持极度轻量，不超过 20 行）：

```
CFM 项目概况：
- 总文件数: 127
- 有表头文件: 13 (10.2%)
- 涵盖领域: auth, billing, legal, ui-interaction, documentation
- 涵盖角色: entry(1), page(7), component(1), script(1), style(1), util(1), example(1)
提示: 使用 cfm_search 按 domain 或 role 精准定位文件，避免逐个探索。
```

**为什么这比全量扫描好**：
- 只有 10-20 行，Token 消耗极低
- 给 AI 一个全局视角，让它知道可以用 cfm_search 搜什么
- 不替代 cfm_search 的按需搜索，只是提供一个"目录页"

---

### P1-2：推广文件头格式标准

**核心洞察**：CFM 的真正竞争力不是 MCP 工具，而是 `/*--- ---*/` 文件头格式本身。

**原因**：
- MCP 工具依赖于用户安装和 AI 客户端支持
- 文件头格式一旦写入代码，任何 AI 看到都能理解，即使没有安装 CFM
- 就像 JSDoc (`/** ... */`) 不需要任何工具也能被人和 AI 理解一样

**行动项**：
1. README 中突出"格式标准"定位，而非仅仅是"MCP 工具"定位
2. 在文档中明确说明：即使不安装 CFM MCP，手动在文件头添加 `/*--- ---*/` 格式的 YAML 注释也能帮助 AI 理解代码
3. 提供一个"30 秒上手"的示例，展示手动添加表头的最简方式
4. 强调 CFM MCP 的价值是"自动化维护这些表头"，而不是表头本身的存在

---

### P2-1：Token 节省效果的对比测试

**目标**：用实际数据证明 CFM 的价值，用于文档和推广。

**测试方案**：
1. 准备一个中等规模项目（50-100 个文件），所有文件都有 CFM 表头
2. 设计 5-10 个典型任务（如"找到认证相关的文件"、"理解积分扣费逻辑"等）
3. 分两组执行：
   - A 组：不使用 CFM，用常规方式（grep + view_file）完成任务
   - B 组：使用 CFM 工作流（cfm_search → cfm_read → 决定是否深读）完成任务
4. 记录每组的工具调用次数、读取的总行数作为 Token 消耗的近似指标
5. 将结果整理成对比表格，放入 README 或专门的"效果展示"页面

---

## 不建议做的事（避免踩坑）

| 冲动 | 为什么不建议 |
|------|------------|
| 增加新的 MCP 工具（如 cfm_impact） | AI 连现有工具都不够主动使用，增加工具反而增加认知负担 |
| 做全量项目索引文件（一次性加载全部表头） | 违背 CFM 的渐进式披露哲学，大项目会消耗大量 Token |
| 让 CFM 接管 AI 的文件读取行为 | 超出 MCP 协议的能力范围，也会让工具变得过于侵入性 |
| 为每种 IDE 开发专用插件 | 资源分散，不如专注于 MCP 标准（所有支持 MCP 的 IDE 都能用） |

---

## 执行优先级总结

```
P0（立即执行，影响最大）:
  P0-1: 优化 4 个 MCP 工具的描述措辞
  P0-2: cfm_read 返回结果中加入 depended_by 反向依赖

P1（近期执行，战略价值高）:
  P1-1: 利用 MCP Resources 暴露轻量项目摘要
  P1-2: README 和文档中强化"文件头格式标准"定位

P2（长期验证）:
  P2-1: Token 节省效果对比测试，用于推广
```

---

## 附录：CFM 设计者的核心意图（供执行 AI 理解上下文）

CFM 的设计目标是让每个代码文件拥有一张"身份证"（YAML 格式的表头注释），
使 AI 在理解代码时可以"先看摘要，再决定是否深读"，从而节省 Token 消耗。

CFM 预期的工作流是：
1. cfm_search → 先按关键词/角色/领域搜索，快速定位候选文件
2. cfm_read（单文件）→ 查看候选文件的表头摘要
3. 根据表头的 intent/exports 判断 → 决定是否需要 view_file 深读全文
4. 修改文件后 → cfm_write 更新表头，保持文档与代码同步

这个工作流的关键是"渐进式披露"：AI 不需要一次性读取所有内容，
而是一层一层深入，每一层都可以决定"够了，不需要继续"。
